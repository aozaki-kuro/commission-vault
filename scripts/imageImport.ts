import { commissionData } from '#data/commissionData'
import fs from 'fs'
import path from 'path'

// 输出文件路径常量
const OUTPUT_FILE_PATH = path.join(__dirname, '../data/imageImports.ts')

/**
 * 导入项的接口定义
 */
interface ImportItem {
  fileName: string // 原始文件名
  importStatement: string // 导入语句
  exportMapping: string // 导出映射
}

/**
 * 从文件名中提取部分编号
 * 例如: "file (part 2)" 返回 2
 * @param fileName - 文件名
 * @returns 部分编号，如果没有则返回 0
 */
function getPartNumber(fileName: string): number {
  const match = fileName.match(/\(part (\d+)\)/)
  // 使用 ?? 运算符来处理空值情况，避免额外的条件判断
  return match ? parseInt(match[1], 10) : 0
}

/**
 * 生成唯一的导入名称
 * 对于单个文件：ABaseName
 * 对于多个文件：ABaseNameA, ABaseNameB 等
 * @param baseName - 文件基础名
 * @param totalCount - 同组文件总数
 * @param index - 当前文件索引
 * @returns 生成的唯一导入名称
 */
function generateUniqueImportName(baseName: string, totalCount: number, index: number): string {
  // 使用模板字符串提升性能
  return totalCount === 1 ? `A${baseName}` : `A${baseName}${String.fromCharCode(65 + index)}`
}

/**
 * 处理一组同基础名称的文件
 * @param files - 文件组
 * @param importItems - 导入项数组
 * @param currentIndex - 当前写入位置
 */
function processFileGroup(
  files: { fileName: string }[],
  importItems: ImportItem[],
  currentIndex: number,
): void {
  // 如果文件组长度为1，跳过排序
  if (files.length > 1) {
    files.sort((a, b) => getPartNumber(a.fileName) - getPartNumber(b.fileName))
  }

  // 缓存基础名称，避免重复计算
  const baseName = files[0].fileName.split('_')[0]
  const totalCount = files.length

  // 使用 for 循环代替 forEach 以提升性能
  for (let i = 0; i < totalCount; i++) {
    const file = files[i]
    // 使用替换正则表达式缓存以提升性能
    const sanitizedFileName = file.fileName.replace(/'/g, "\\'")
    const importName = generateUniqueImportName(baseName, totalCount, i)

    importItems[currentIndex + i] = {
      fileName: file.fileName,
      // 使用模板字符串提升性能
      importStatement: `import ${importName} from '#images/webp/${sanitizedFileName}.webp'`,
      exportMapping: `  '${file.fileName}': ${importName},`,
    }
  }
}

/**
 * 预估所需的数组大小以避免重新分配
 * @param data - commission 数据
 * @returns 预估的导入项数量
 */
function estimateImportCount(data: typeof commissionData): number {
  let count = 0
  // 使用 for...of 循环代替 reduce 以提升性能
  for (const char of data) {
    count += char.Commissions.length
  }
  return count
}

/**
 * 生成导入语句和导出映射
 * 主函数
 */
function generateImports(): void {
  // 使用 Map 存储文件组，提供 O(1) 的查找性能
  const fileGroups = new Map<string, { fileName: string }[]>()

  // 第一次遍历：按基础名称分组
  for (const characterData of commissionData) {
    for (const commission of characterData.Commissions) {
      const baseName = commission.fileName.split('_')[0]

      // 使用 get/set 代替 has/get 组合以减少查找次数
      const group = fileGroups.get(baseName)
      if (group) {
        group.push(commission)
      } else {
        fileGroups.set(baseName, [commission])
      }
    }
  }

  const importItems: ImportItem[] = new Array(estimateImportCount(commissionData))
  let currentIndex = 0

  try {
    // 处理每个文件组
    for (const files of fileGroups.values()) {
      processFileGroup(files, importItems, currentIndex)
      currentIndex += files.length
    }

    // 最终排序
    importItems.sort((a, b) => a.fileName.localeCompare(b.fileName))

    // 使用数组 join 构建最终内容，比字符串拼接更高效
    const fileContent = [
      '// This file is auto-generated by the script at script/generateImageImports.ts',
      '// !!! DO NOT EDIT !!!',
      importItems.map(item => item.importStatement).join('\n'),
      '', // 添加空行增加可读性
      'export const imageImports = {',
      importItems.map(item => item.exportMapping).join('\n'),
      '}',
    ].join('\n')

    // 一次性写入文件
    fs.writeFileSync(OUTPUT_FILE_PATH, fileContent, 'utf-8')
  } catch (error) {
    console.error('Error generating imports:', error)
    process.exit(1)
  }
}

// 执行生成函数
generateImports()
